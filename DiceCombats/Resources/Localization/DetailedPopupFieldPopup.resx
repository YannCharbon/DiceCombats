<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- Microsoft ResX Schema ... trimmed for brevity -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>

  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>

  <data name="DetailedPopupShowEditorHelp" xml:space="preserve">
    <value>Show editing help</value>
  </data>

  <data name="DetailedPopupOverviewTitle" xml:space="preserve">
    <value>Overview</value>
  </data>
  <data name="DetailedPopupOverviewBody" xml:space="preserve">
    <value><![CDATA[
<p>
Add one or more <b>content entries</b>. Each entry has a <i>Kind</i> that defines how it renders:
<span class="kbd">text</span>, <span class="kbd">markdown</span>, <span class="kbd">html (templated)</span>, or <span class="kbd">pdf</span>.
Use the <i>Name</i> to group pieces visually within the popup.
</p>
<ul>
  <li><b>Search</b> filters results by group title, entry name/key, and indexed text.</li>
  <li><b>Grid/List</b> toggle changes the layout; grid uses a masonry layout.</li>
</ul>
]]></value>
  </data>

  <data name="DetailedPopupTextTitle" xml:space="preserve">
    <value>text</value>
  </data>
  <data name="DetailedPopupTextBody" xml:space="preserve">
    <value><![CDATA[
<p>
Use the <b>Content</b> box to write plain text. It will be rendered as simple paragraphs (with preserved line breaks)
and indexed as a single block for search.
</p>
]]></value>
  </data>

  <data name="DetailedPopupMarkdownTitle" xml:space="preserve">
    <value>markdown</value>
  </data>
  <data name="DetailedPopupMarkdownBody" xml:space="preserve">
    <value><![CDATA[
<p>
Markdown is converted to HTML using the <b>Markdig</b> pipeline (advanced extensions enabled).
The raw markdown is stored and indexed so that search works on the original text.
</p>
<p>
This is useful for descriptions that benefit from headings, lists, emphasis, or tables while remaining easy to edit.
</p>
]]></value>
  </data>

  <data name="DetailedPopupPdfTitle" xml:space="preserve">
    <value>pdf</value>
  </data>
  <data name="DetailedPopupPdfBody" xml:space="preserve">
    <value><![CDATA[
<p>
Pick a PDF file. The renderer will create <b>one piece per page</b> using <code>pdf.js</code> for visual rendering.
When text extraction is possible, each page is also indexed for search.
</p>
<ul>
  <li>Large PDFs are supported; the first render may take a bit longer.</li>
  <li>If parsing fails, you still see the pages visually, but search on page contents is disabled.</li>
</ul>
]]></value>
  </data>

  <data name="DetailedPopupHtmlHowItWorksTitle" xml:space="preserve">
    <value>html (templated) — how it works</value>
  </data>
  <data name="DetailedPopupHtmlHowItWorksBody" xml:space="preserve">
    <value><![CDATA[
<ol>
  <li><b>Source</b>: choose <span class="kbd">Paste HTML</span> or <span class="kbd">Pick file</span>.</li>
  <li><b>selector</b>: CSS selector that matches <i>multiple</i> nodes; each match becomes one rendered piece.</li>
  <li><b>template</b>: Handlebars-style template that renders each matched node.</li>
  <li><b>map.json</b>: optional JSON mapping keys → CSS selectors evaluated within the matched node.</li>
  <li><b>css</b>: optional CSS injected once for the entire popup, used by your template output.</li>
</ol>
<p>
Default variables always available:
<span class="kbd">{{{html}}}</span> (inner HTML) and <span class="kbd">{{text}}</span> (inner text).
</p>
]]></value>
  </data>

  <data name="DetailedPopupHtmlTipsTitle" xml:space="preserve">
    <value>html (templated) — template &amp; map.json tips</value>
  </data>
  <data name="DetailedPopupHtmlTipsBody" xml:space="preserve">
    <value><![CDATA[
<ul>
  <li><b>Triple braces</b> <span class="kbd">{{{key}}}</span> render raw HTML; <span class="kbd">{{key}}</span> is HTML-escaped.</li>
  <li><b>Helpers</b> like <span class="kbd">{{#if key}}</span> and <span class="kbd">{{#each list}}</span> are supported.</li>
  <li>
    <b>map.json</b>:
    <ul>
      <li>Keys become variables in the template.</li>
      <li><span class="kbd">rows</span> (special): when the selector returns multiple nodes, you get an array (for <span class="kbd">{{#each}}</span>).</li>
      <li>Shorthands: <span class="kbd">~selfHtml</span> → current node inner HTML, any other <span class="kbd">~something</span> → current node text.</li>
      <li>Defaults added if missing: <span class="kbd">html</span>, <span class="kbd">text</span>.</li>
    </ul>
  </li>
  <li><b>CSS collisions</b>: prefix your classes (e.g. <span class="kbd">dc-card</span>) to avoid clashing with global styles.</li>
</ul>
]]></value>
  </data>

  <data name="DetailedPopupHtmlQuickStartTitle" xml:space="preserve">
    <value>html (templated) — quick starter example</value>
  </data>
  <data name="DetailedPopupHtmlQuickStartBody" xml:space="preserve">
    <value><![CDATA[
<p>
A minimal end-to-end pattern to validate your pipeline (<b>selector</b> → <b>map.json</b> → <b>template</b> → <b>CSS</b>).
Each element matched by the selector is turned into one rendered “piece”.
</p>
<ul>
  <li>
    <p><b>selector</b>: <span class="kbd">.card</span></p>
    <p>
      This selects every <span class="kbd">&lt;div class="card"&gt;...&lt;/div&gt;</span> in your HTML. For each match,
      the renderer builds a data model (from <b>map.json</b>) and feeds it to the Handlebars <b>template</b>.
    </p>
  </li>
  <li>
    <p><b>template</b> (Handlebars):</p>
    <pre class="kbd" style="white-space:pre-wrap">
&lt;div class="dc-card"&gt;
  &lt;h4&gt;{{{title}}}&lt;/h4&gt;
  {{#if props}}&lt;ul&gt;{{#each props}}&lt;li&gt;{{{this}}}&lt;/li&gt;{{/each}}&lt;/ul&gt;{{/if}}
  {{#if body}}&lt;div class="dc-body"&gt;{{{body}}}&lt;/div&gt;{{/if}}
&lt;/div&gt;
</pre>
    <p style="margin-top:6px">
      Notes:
      <br />• <span class="kbd">{{{title}}}</span> and <span class="kbd">{{{body}}}</span> use triple mustaches to allow HTML (unescaped).
      <br />• <span class="kbd">{{#if props}}…{{/if}}</span> conditionally renders a block if the array exists/non-empty.
      <br />• <span class="kbd">{{#each props}}…{{/each}}</span> loops over the array created by <b>map.json</b>.
    </p>
    <p style="margin-top:6px">
      Handlebars reference:
      <a style="color:darkcyan" href="https://handlebarsjs.com/guide/" target="_blank" rel="noopener">handlebarsjs.com/guide</a>
    </p>
  </li>
  <li>
    <p><b>css</b> (inlined in the field’s “css” box):</p>
    <pre class="kbd" style="white-space:pre-wrap">
.dc-card{background:#2b2e3a;border:1px solid #666;border-radius:10px;padding:12px;margin:8px 0;}
.dc-card h4{margin:0 0 6px 0;font-weight:800;}
.dc-card ul{margin:6px 0 0 18px;padding:0;}
.dc-body{margin-top:6px;line-height:1.35;}
</pre>
    <p style="margin-top:6px">
      Tip: keep CSS here, not inside the HTML input. The popup aggregates CSS from all “html (templated)” entries
      and injects it only once to avoid duplicates.
    </p>
  </li>
  <li>
    <p><b>map.json</b> (selectors are resolved <i>inside each matched .card</i>):</p>
    <pre class="kbd" style="white-space:pre-wrap">
{"title":"h3","body":".content","props":".props li"}
</pre>
    <p style="margin-top:6px">
      • <span class="kbd">"title":"h3"</span> → capture the inner HTML of the first <span class="kbd">&lt;h3&gt;</span>.<br />
      • <span class="kbd">"body":".content"</span> → capture the inner HTML of the <span class="kbd">.content</span> div.<br />
      • <span class="kbd">"props":".props li"</span> → collect all list items into an array.
    </p>
  </li>
  <li>
    <p><b>raw html input</b>:</p>
    <pre class="kbd" style="white-space:pre-wrap">
&lt;div class="card"&gt;
  &lt;h3&gt;Magic Missile&lt;/h3&gt;
  &lt;ul class="props"&gt;
    &lt;li&gt;Casting Time: 1 action&lt;/li&gt;
    &lt;li&gt;Range: 36 m&lt;/li&gt;
  &lt;/ul&gt;
  &lt;div class="content"&gt;You create three glowing darts of magical force...&lt;/div&gt;
&lt;/div&gt;

&lt;div class="card"&gt;
  &lt;h3&gt;Shield&lt;/h3&gt;
  &lt;ul class="props"&gt;
    &lt;li&gt;Casting Time: 1 reaction&lt;/li&gt;
    &lt;li&gt;Duration: 1 round&lt;/li&gt;
  &lt;/ul&gt;
  &lt;div class="content"&gt;An invisible barrier of magical force appears and protects you...&lt;/div&gt;
&lt;/div&gt;
</pre>
    <p style="margin-top:6px">
      With the selector <span class="kbd">.card</span>, this produces two pieces (one per card).
      If nothing renders, first verify the selector matches your HTML.
    </p>
  </li>
</ul>
<p>
<b>How it renders:</b> each <span class="kbd">&lt;div class="card"&gt;…&lt;/div&gt;</span> becomes one piece.
The mapper picks <span class="kbd">h3</span> → <span class="kbd">{{{title}}}</span>,
every <span class="kbd">.props li</span> → <span class="kbd">props</span> array,
and <span class="kbd">.content</span> → <span class="kbd">{{{body}}}</span>.
</p>
]]></value>
  </data>

  <data name="DetailedPopupTroubleshootingTitle" xml:space="preserve">
    <value>Troubleshooting</value>
  </data>
  <data name="DetailedPopupTroubleshootingBody" xml:space="preserve">
    <value><![CDATA[
<ul>
  <li><b>No cards?</b> Verify your <i>selector</i> matches elements in the provided HTML.</li>
  <li><b>Missing values?</b> Ensure the key exists in <i>map.json</i> and the CSS selector matches a child element.</li>
  <li><b>Broken layout?</b> Keep your CSS specific and avoid very generic rules.</li>
  <li><b>Search misses content?</b> The index comes from <span class="kbd">text</span> (or mapped fields) per piece, plus group titles and keys.</li>
</ul>
]]></value>
  </data>

  <data name="DetailedPopupInlineHelpHtml" xml:space="preserve">
    <value><![CDATA[
<b>html (templated)</b> entry:
<ul style="margin:6px 0;">
  <li>Set <span class="kbd">selector</span> to pick repeated nodes (one piece per match).</li>
  <li>Write a Handlebars-style <span class="kbd">template</span> using keys from <span class="kbd">map.json</span>.</li>
  <li>Optional <span class="kbd">css</span> applies to all pieces (injected once in the popup).</li>
  <li><span class="kbd">source</span>: choose <i>Paste HTML</i> or <i>Pick file</i> below.</li>
</ul>
]]></value>
  </data>

  <data name="DetailedPopupDeleteTooltip" xml:space="preserve">
    <value>Delete this content</value>
  </data>
  <data name="DetailedPopupDeleteButton" xml:space="preserve">
    <value>Delete</value>
  </data>

  <data name="DetailedPopupContentNameLabel" xml:space="preserve">
    <value>Content name (optional)</value>
  </data>
  <data name="DetailedPopupKindLabel" xml:space="preserve">
    <value>Kind</value>
  </data>
  <data name="DetailedPopupKindTextLabel" xml:space="preserve">
    <value>text</value>
  </data>
  <data name="DetailedPopupKindMarkdownLabel" xml:space="preserve">
    <value>markdown</value>
  </data>
  <data name="DetailedPopupKindHtmlLabel" xml:space="preserve">
    <value>html (templated)</value>
  </data>
  <data name="DetailedPopupKindPdfLabel" xml:space="preserve">
    <value>pdf</value>
  </data>

  <data name="DetailedPopupTextContentLabel" xml:space="preserve">
    <value>Content</value>
  </data>
  <data name="DetailedPopupMarkdownContentLabel" xml:space="preserve">
    <value>Markdown content</value>
  </data>

  <data name="DetailedPopupSelectorLabel" xml:space="preserve">
    <value>selector</value>
  </data>
  <data name="DetailedPopupTemplateLabel" xml:space="preserve">
    <value>template</value>
  </data>
  <data name="DetailedPopupCssLabel" xml:space="preserve">
    <value>css</value>
  </data>
  <data name="DetailedPopupMapJsonLabel" xml:space="preserve">
    <value>map.json</value>
  </data>

  <data name="DetailedPopupHtmlSourceInlineLabel" xml:space="preserve">
    <value>Paste HTML</value>
  </data>
  <data name="DetailedPopupHtmlSourceFileLabel" xml:space="preserve">
    <value>Pick file</value>
  </data>

  <data name="DetailedPopupHtmlContentLabel" xml:space="preserve">
    <value>HTML content</value>
  </data>
  <data name="DetailedPopupFilePathLabel" xml:space="preserve">
    <value>File path</value>
  </data>
  <data name="DetailedPopupPickFileButton" xml:space="preserve">
    <value>Pick file</value>
  </data>

  <data name="DetailedPopupLoadedBytesCaption" xml:space="preserve">
    <value>Loaded {0} bytes</value>
  </data>

  <data name="DetailedPopupPdfInlineHelp" xml:space="preserve">
    <value>Load a PDF file. Each page becomes a searchable piece (when text extraction is possible).</value>
  </data>

  <data name="DetailedPopupSearchPlaceholder" xml:space="preserve">
    <value>Search…</value>
  </data>
  <data name="DetailedPopupToggleGridTooltip" xml:space="preserve">
    <value>Toggle grid/list view</value>
  </data>

  <data name="DetailedPopupDeleteDialogTitle" xml:space="preserve">
    <value>Delete content</value>
  </data>
  <data name="DetailedPopupDeleteDialogMessage" xml:space="preserve">
    <value>This action cannot be undone.&lt;br/&gt;Do you want to delete this content?</value>
  </data>
  <data name="DetailedPopupDeleteDialogYes" xml:space="preserve">
    <value>Delete</value>
  </data>
  <data name="DetailedPopupDeleteDialogCancel" xml:space="preserve">
    <value>Cancel</value>
  </data>

  <data name="DetailedPopupAddNewContentButton" xml:space="preserve">
    <value>Add new content</value>
  </data>
</root>
